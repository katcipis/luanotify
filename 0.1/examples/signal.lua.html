<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>LuaNotify Documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>LuaNotify</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Examples</h2>
<ul>
  <li><a href="../examples/double-queue.lua.html">double-queue.lua</a></li>
  <li><a href="../examples/event.lua.html">event.lua</a></li>
  <li><strong>signal.lua</strong></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/notify.double-queue.html">notify.double-queue</a></li>
  <li><a href="../modules/notify.event.html">notify.event</a></li>
  <li><a href="../modules/notify.signal.html">notify.signal</a></li>
</ul>
<h2>Topics</h2>
<ul>
  <li><a href="../topics/01-introduction.md.html">01-introduction.md</a></li>
</ul>

</div>

<div id="content">

<h1>Example <code>signal.lua</code></h1>

    <pre>
<span class="comment">--------------------------------------------------------------------------------
</span>
<span class="comment">-- Copyright (C) 2010 Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
</span><span class="comment">-- Copyright (C) 2010 Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
</span>
<span class="comment">-- @author Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
</span><span class="comment">-- @author Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
</span> 
<span class="comment">-- This file is part of LuaNotify.
</span> 
<span class="comment">-- LuaNotify is free software: you can redistribute it and/or modify
</span><span class="comment">-- it under the terms of the GNU Lesser General Public License as published by
</span><span class="comment">-- the Free Software Foundation, either version 3 of the License, or
</span><span class="comment">-- (at your option) any later version.
</span> 
<span class="comment">-- LuaNotify is distributed in the hope that it will be useful,
</span><span class="comment">-- but WITHOUT ANY WARRANTY; without even the implied warranty of
</span><span class="comment">-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</span><span class="comment">-- GNU Lesser General Public License for more details.
</span> 
<span class="comment">-- You should have received a copy of the GNU Lesser General Public License
</span><span class="comment">-- along with LuaNotify.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
</span><span class="comment">---------------------------------------------------------------------------------
</span>
<span class="global">require</span> <span class="string">"lunit"</span>
<span class="global">package</span>.path = <span class="global">package</span>.path..<span class="string">";../?.lua"</span>
<span class="global">module</span>(<span class="string">"signal_testcase"</span>, lunit.testcase, <span class="global">package</span>.seeall)

<span class="keyword">local</span> signal_module = <span class="global">require</span> <span class="string">"notify.signal"</span>


<span class="keyword">function</span> setUp()
    signal = signal_module.new()
    call_counter = <span class="number">0</span>
<span class="keyword">end</span>

<span class="keyword">function</span> tearDown()
    signal = <span class="keyword">nil</span>
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_a_handler_function_is_connected_it_will_always_be_called_when_a_emission_occurs()

    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>

    signal:connect(handler)
    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter) 
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_there_is_no_handler_connected_emission_does_nothing()
    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">0</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_handlers_are_called_on_a_queue_behavior()
    handler1 = <span class="keyword">function</span> ()
                   assert_equal(<span class="number">0</span>, call_counter)
                   call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler2 = <span class="keyword">function</span> ()
                   assert_equal(<span class="number">1</span>, call_counter)
                   call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler3 = <span class="keyword">function</span> ()
                   assert_equal(<span class="number">2</span>, call_counter)
                   call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

     signal:connect(handler1)
     signal:connect(handler2)
     signal:connect(handler3)
     signal:emit()
<span class="keyword">end</span>


<span class="keyword">function</span> test_handlers_receive_all_the_data_that_is_passed_on_emission()
    handler  = <span class="keyword">function</span> (arg)
                   assert_equal(<span class="string">"pineapple"</span>, arg)
               <span class="keyword">end</span>

    signal:connect(handler)
    signal:emit(<span class="string">"pineapple"</span>)
<span class="keyword">end</span>


<span class="keyword">function</span> test_handlers_receive_all_the_data_that_is_passed_on_emission_on_the_order_it_was_on_emission_call()

    handler = <span class="keyword">function</span> (arg1,arg2,arg3)
                   assert_equal(<span class="number">1</span>, arg1)
                   assert_equal(<span class="number">2</span>, arg2)
                   assert_equal(<span class="string">"pineapple"</span>, arg3)
               <span class="keyword">end</span>

    signal:connect(handler)
    signal:emit(<span class="number">1</span>,<span class="number">2</span>,<span class="string">"pineapple"</span>)

<span class="keyword">end</span>


<span class="keyword">function</span> test_if_the_same_handler_is_connected_multiple_times_it_will_be_called_only_once()
    handler = <span class="keyword">function</span> ()
                  call_counter = call_counter + <span class="number">1</span>
              <span class="keyword">end</span>

    signal:connect(handler)
    signal:connect(handler)
    signal:connect(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_the_same_handler_is_connected_multiple_times_it_has_to_be_disconnected_only_once()
    handler = <span class="keyword">function</span> ()
                  call_counter = call_counter + <span class="number">1</span>
              <span class="keyword">end</span>
    
    signal:connect(handler)
    signal:connect(handler)
    signal:connect(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:disconnect(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_same_handler_can_be_connected_on_multiple_signals()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">local</span> signal2 = signal_module.new()
    
    signal:connect(handler)
    signal2:connect(handler)

    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal2:emit()
    assert_equal(<span class="number">2</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_you_disconnect_a_handler_that_is_not_connected_nothing_happens()
    handler  = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>
    signal:disconnect(handler)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_a_handler_is_disconnected_the_order_of_the_remaining_handlers_wont_change()
    handler1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler3 = <span class="keyword">function</span> (offset)
                  <span class="keyword">local</span> offset = offset <span class="keyword">or</span> <span class="number">0</span>
                  assert_equal(<span class="number">2</span> - offset, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:connect(handler3)
    signal:emit()

    signal:disconnect(handler2)
    call_counter = <span class="number">0</span>
    signal:emit(<span class="number">1</span>)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_a_handler_is_disconnected_it_will_not_be_called_anymore()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>

    signal:connect(handler)
    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:disconnect(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_a_handler_got_blocked_it_wont_be_called_on_emission()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>

    signal:connect(handler)
    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:block(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_you_block_a_handler_that_does_not_exist_nothing_happens()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>
    signal:block(handler)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_you_unblock_a_handler_that_does_not_exist_nothing_happens()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>
    signal:unblock(handler)
<span class="keyword">end</span>


<span class="keyword">function</span> test_a_blocked_handler_can_be_unblocked()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>

    signal:connect(handler)
    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:block(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:unblock(handler)
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_a_unblocked_handler_will_be_called_on_its_original_position()
    handler1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler3 = <span class="keyword">function</span> (offset)
                  <span class="keyword">local</span> offset = offset <span class="keyword">or</span> <span class="number">0</span>
                  assert_equal(<span class="number">2</span> - offset, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:connect(handler3)
    signal:block(handler2)
    signal:emit(<span class="number">1</span>)
 
    call_counter = <span class="number">0</span>
    signal:unblock(handler2)
    signal:emit()   
<span class="keyword">end</span>


<span class="keyword">function</span> test_a_handler_must_be_unblocked_the_same_times_it_has_been_blocked()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>

    signal:connect(handler)
    signal:block(handler)
    signal:block(handler)
    signal:block(handler)

    signal:emit()
    assert_equal(<span class="number">0</span>, call_counter)
    
    signal:unblock(handler)
    signal:emit()
    assert_equal(<span class="number">0</span>, call_counter)

    signal:unblock(handler)
    signal:emit()
    assert_equal(<span class="number">0</span>, call_counter)

    signal:unblock(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_pre_emit_functions_are_always_called_before_the_handlers()
    handler1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    pre_emit =   <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span> , call_counter)
               <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:add_pre_emit(pre_emit)
    signal:emit()
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_same_pre_emit_can_be_added_on_multiple_signals()
    <span class="keyword">local</span> pre_emit = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">local</span> signal2 = signal_module.new()

    signal:add_pre_emit(pre_emit)
    signal2:add_pre_emit(pre_emit)

    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal2:emit()
    assert_equal(<span class="number">2</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_the_same_pre_emit_is_added_multiple_times_it_will_be_called_only_once()
    pre_emit = <span class="keyword">function</span> ()
                 call_counter = call_counter + <span class="number">1</span>
             <span class="keyword">end</span>
    
    signal:add_pre_emit(pre_emit)
    signal:add_pre_emit(pre_emit)
    signal:add_pre_emit(pre_emit)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_the_same_pre_emit_is_added_multiple_times_it_has_to_be_removed_only_once()
    pre_emit = <span class="keyword">function</span> ()
                 call_counter = call_counter + <span class="number">1</span>
             <span class="keyword">end</span>
                  
    signal:add_pre_emit(pre_emit)
    signal:add_pre_emit(pre_emit)
    signal:add_pre_emit(pre_emit)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:remove_pre_emit(pre_emit)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_pre_emit_functions_are_called_on_a_queue_behavior()
    handler  = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    pre_emit1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    pre_emit2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    signal:connect(handler)
    signal:add_pre_emit(pre_emit1)
    signal:add_pre_emit(pre_emit2)
    signal:emit()
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_you_remove_a_pre_emit_that_does_not_exist_nothing_happens()
    pre_emit   = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
               <span class="keyword">end</span>

    signal:remove_pre_emit(pre_emit)
<span class="keyword">end</span>


<span class="keyword">function</span> test_after_removing_a_pre_emit_function_the_order_of_the_pre_emits_remain_the_same()
    pre_emit1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    pre_emit2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    <span class="keyword">local</span> offset = <span class="number">0</span>
    pre_emit3 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span> - offset, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    signal:add_pre_emit(pre_emit1)
    signal:add_pre_emit(pre_emit2)
    signal:add_pre_emit(pre_emit3)
    signal:emit()

    signal:remove_pre_emit(pre_emit2)
    offset = <span class="number">1</span>; call_counter = <span class="number">0</span>
    signal:emit()

<span class="keyword">end</span>


<span class="keyword">function</span> test_pre_emit_functions_are_called_only_once_before_the_handlers()
    handler1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    pre_emit =   <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span> , call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:add_pre_emit(pre_emit)
    signal:emit()
<span class="keyword">end</span>


<span class="keyword">function</span> test_no_emission_data_is_passed_to_the_pre_emit_functions()
    handler = <span class="keyword">function</span> (arg)
                  assert_not_equal(<span class="keyword">nil</span>, arg)
              <span class="keyword">end</span>

    pre_emit =  <span class="keyword">function</span> (arg)
                  assert_equal(<span class="keyword">nil</span>, arg)
              <span class="keyword">end</span>

    signal:connect(handler)
    signal:add_pre_emit(pre_emit)
    signal:emit(<span class="string">"some_data"</span>)
<span class="keyword">end</span>


<span class="keyword">function</span> test_after_being_removed_a_pre_emit_function_wont_be_called_anymore()
    pre_emit1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    pre_emit2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    <span class="keyword">local</span> offset = <span class="number">0</span>
    pre_emit3 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span> - offset, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    signal:add_pre_emit(pre_emit1)
    signal:add_pre_emit(pre_emit2)
    signal:add_pre_emit(pre_emit3)
    signal:emit()

    signal:remove_pre_emit(pre_emit2)
    offset = <span class="number">1</span>; call_counter = <span class="number">0</span>
    signal:emit()
<span class="keyword">end</span>


<span class="keyword">function</span> test_post_emit_functions_are_always_called_after_the_handlers()
    handler1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    post_emit = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span> , call_counter)
                  call_counter = call_counter + <span class="number">1</span>
                <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:add_post_emit(post_emit)
    signal:emit()
    assert_equal(<span class="number">3</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_same_post_emit_can_be_added_on_multiple_signals()
    <span class="keyword">local</span> post_emit = <span class="keyword">function</span> () call_counter = call_counter + <span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">local</span> signal2 = signal_module.new()

    signal:add_post_emit(post_emit)
    signal2:add_post_emit(post_emit)

    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal2:emit()
    assert_equal(<span class="number">2</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_post_emit_functions_are_called_only_once_after_the_handlers()
    handler1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    handler2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    post_emit = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span> , call_counter)
                  call_counter = call_counter + <span class="number">1</span>
                <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:add_post_emit(post_emit)
    signal:emit()
    assert_equal(<span class="number">3</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_no_emission_data_is_passed_to_the_post_emit_functions()
    handler   = <span class="keyword">function</span> (arg)
                  assert_not_equal(<span class="keyword">nil</span>, arg)
              <span class="keyword">end</span>

    post_emit = <span class="keyword">function</span> (arg)
                  assert_equal(<span class="keyword">nil</span>, arg)
              <span class="keyword">end</span>

    signal:connect(handler)
    signal:add_post_emit(post_emit)
    signal:emit(<span class="string">"some_data"</span>)
<span class="keyword">end</span>


<span class="keyword">function</span> test_after_being_removed_a_post_emit_function_wont_be_called_anymore()
    post_emit1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    post_emit2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    <span class="keyword">local</span> offset = <span class="number">0</span>
    post_emit3 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span> - offset, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    signal:add_post_emit(post_emit3)
    signal:add_post_emit(post_emit2)
    signal:add_post_emit(post_emit1)
    signal:emit()
    assert_equal(<span class="number">3</span>, call_counter)

    signal:remove_post_emit(post_emit2)
    offset = <span class="number">1</span>; call_counter = <span class="number">0</span>
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter)

<span class="keyword">end</span>


<span class="keyword">function</span> test_if_the_same_post_emit_is_added_multiple_times_it_will_be_called_only_once()
    post_emit = <span class="keyword">function</span> ()
                    call_counter = call_counter + <span class="number">1</span>
                <span class="keyword">end</span>
                  
    signal:add_post_emit(post_emit)
    signal:add_post_emit(post_emit)
    signal:add_post_emit(post_emit)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_the_same_post_emit_is_added_multiple_times_it_has_to_be_removed_only_once()
    post_emit = <span class="keyword">function</span> ()
                    call_counter = call_counter + <span class="number">1</span>
                <span class="keyword">end</span>

    signal:add_post_emit(post_emit)
    signal:add_post_emit(post_emit)
    signal:add_post_emit(post_emit)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
    signal:remove_post_emit(post_emit)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_post_emit_functions_are_called_on_a_stack_behavior()
    post_emit1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    post_emit2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    post_emit3 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    assert_equal(<span class="number">0</span>, call_counter)
    signal:add_post_emit(post_emit3)
    signal:add_post_emit(post_emit2)
    signal:add_post_emit(post_emit1)
    signal:emit()
    assert_equal(<span class="number">3</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_after_removing_a_post_emit_function_the_order_of_the_post_emits_remain_the_same()
    post_emit1 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    post_emit2 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">1</span>, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    <span class="keyword">local</span> offset = <span class="number">0</span>
    post_emit3 = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">2</span> - offset, call_counter)
                  call_counter = call_counter + <span class="number">1</span>
               <span class="keyword">end</span>

    assert_equal(<span class="number">0</span>, call_counter)
    signal:add_post_emit(post_emit3)
    signal:add_post_emit(post_emit2)
    signal:add_post_emit(post_emit1)
    signal:emit()
    assert_equal(<span class="number">3</span>, call_counter)

    signal:remove_post_emit(post_emit2)
    offset = <span class="number">1</span>; call_counter = <span class="number">0</span>
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_you_remove_a_post_emit_that_does_not_exist_nothing_happens()
    post_emit  = <span class="keyword">function</span> ()
                  assert_equal(<span class="number">0</span>, call_counter)
               <span class="keyword">end</span>

    signal:remove_post_emit(post_emit)
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_return_value_of_each_handler_is_passed_to_the_accumulator()
    <span class="keyword">local</span> handler1 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">0</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                         <span class="keyword">return</span> call_counter
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler2 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">1</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                         <span class="keyword">return</span> call_counter
                     <span class="keyword">end</span>

    <span class="keyword">local</span> counter = <span class="number">0</span>

    <span class="keyword">local</span> accumulator = <span class="keyword">function</span> (arg1)
                            counter = counter + arg1
                        <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:emit_with_accumulator(accumulator)
    assert_equal(<span class="number">2</span>, call_counter)
    assert_equal(<span class="number">3</span>, counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_after_the_execution_of_each_handler_the_accumulator_is_called()
    <span class="keyword">local</span> handler1 = <span class="keyword">function</span> ()
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler2 = <span class="keyword">function</span> ()
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    <span class="keyword">local</span> counter = <span class="number">0</span>

    <span class="keyword">local</span> accumulator = <span class="keyword">function</span> ()
                            counter = counter + <span class="number">1</span>
                            assert_equal(call_counter, counter)
                        <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:emit_with_accumulator(accumulator)
<span class="keyword">end</span>


<span class="keyword">function</span> test_even_when_the_handler_returns_nil_it_is_repassed_to_the_accumulator()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> ()
                    <span class="keyword">end</span>

    <span class="keyword">local</span> accumulator = <span class="keyword">function</span> (arg)
                            assert_equal(arg, <span class="keyword">nil</span>)
                        <span class="keyword">end</span>

    signal:connect(handler)
    signal:emit_with_accumulator(accumulator)
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_handlers_can_return_multiple_values_to_the_accumulator()
    <span class="keyword">local</span> handler = <span class="keyword">function</span> ()
                        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>
                    <span class="keyword">end</span>

    <span class="keyword">local</span> accumulator = <span class="keyword">function</span> (arg1, arg2)
                            assert_equal(arg1, <span class="number">1</span>)
                            assert_equal(arg2, <span class="number">2</span>)
                        <span class="keyword">end</span>

    signal:connect(handler)
    signal:emit_with_accumulator(accumulator)
<span class="keyword">end</span>


<span class="keyword">function</span> test_pre_emit_functions_return_values_are_not_passed_to_the_accumulator()
    <span class="keyword">local</span> pre_emit = <span class="keyword">function</span> ()
                       <span class="keyword">return</span> <span class="number">1</span>
                   <span class="keyword">end</span>

    <span class="keyword">local</span> handler = <span class="keyword">function</span> ()
                       <span class="keyword">return</span> <span class="number">2</span>
                    <span class="keyword">end</span>

    <span class="keyword">local</span> accumulator = <span class="keyword">function</span> (arg)
                            assert_equal(arg, <span class="number">2</span>)
                        <span class="keyword">end</span>

    signal:add_pre_emit(pre_emit)
    signal:connect(handler)
    signal:emit_with_accumulator(accumulator)
<span class="keyword">end</span>


<span class="keyword">function</span> test_post_emit_functions_return_values_are_not_passed_to_the_accumulator()
    <span class="keyword">local</span> post_emit = <span class="keyword">function</span> ()
                          <span class="keyword">return</span> <span class="number">1</span>
                      <span class="keyword">end</span>

    <span class="keyword">local</span> handler = <span class="keyword">function</span> ()
                       <span class="keyword">return</span> <span class="number">2</span>
                    <span class="keyword">end</span>

    <span class="keyword">local</span> accumulator = <span class="keyword">function</span> (arg)
                            assert_equal(arg, <span class="number">2</span>)
                        <span class="keyword">end</span>

    signal:add_post_emit(post_emit)
    signal:connect(handler)
    signal:emit_with_accumulator(accumulator)
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_a_signal_is_stopped_no_more_handlers_are_called_on_that_emission()
    
    <span class="keyword">local</span> handler1 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">0</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler2 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">1</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                         signal:stop()
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler3 = <span class="keyword">function</span> ()
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:connect(handler3)

    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter) 
<span class="keyword">end</span>


<span class="keyword">function</span> test_if_a_signal_is_stopped_it_wil_be_stop_only_the_current_emission()

    <span class="keyword">local</span> handler1 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">0</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler2 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">1</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                         signal:stop()
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler3 = <span class="keyword">function</span> ()
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:connect(handler3)

    assert_equal(<span class="number">0</span>, call_counter)
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter)
    signal:disconnect(handler2)
    call_counter = <span class="number">0</span>
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter)
    
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_signal_emission_can_be_stopped_inside_a_handler()
    <span class="keyword">local</span> handler1 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">0</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                         signal:stop()
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler2 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">1</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_signal_emission_can_be_stopped_inside_a_pre_emit()
    <span class="keyword">local</span> pre_emit = <span class="keyword">function</span> ()
                       assert_equal(<span class="number">0</span>, call_counter)
                       call_counter = call_counter + <span class="number">1</span>
                       signal:stop()
                   <span class="keyword">end</span>

    <span class="keyword">local</span> handler = <span class="keyword">function</span> ()
                        assert_equal(<span class="number">1</span>, call_counter)
                        call_counter = call_counter + <span class="number">1</span>
                    <span class="keyword">end</span>

    signal:add_pre_emit(pre_emit)
    signal:connect(handler)
    signal:emit()
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_the_signal_emission_can_be_stopped_inside_a_accumulator()
    <span class="keyword">local</span> handler1 = <span class="keyword">function</span> ()
                        assert_equal(<span class="number">0</span>, call_counter)
                        call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler2 = <span class="keyword">function</span> ()
                        assert_equal(<span class="number">1</span>, call_counter)
                        call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    <span class="keyword">local</span> accumulator = <span class="keyword">function</span> ()
                            signal:stop()
                        <span class="keyword">end</span>

    signal:connect(handler1)
    signal:connect(handler2)
    signal:emit_with_accumulator(accumulator)
    assert_equal(<span class="number">1</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_stopping_a_signal_will_not_stop_the_pre_emit_functions()
    <span class="keyword">local</span> pre_emit1 = <span class="keyword">function</span> ()
                        assert_equal(<span class="number">0</span>, call_counter)
                        call_counter = call_counter + <span class="number">1</span>
                        signal:stop()
                    <span class="keyword">end</span>

    <span class="keyword">local</span> pre_emit2 = <span class="keyword">function</span> ()
                        assert_equal(<span class="number">1</span>, call_counter)
                        call_counter = call_counter + <span class="number">1</span>
                    <span class="keyword">end</span>

    <span class="keyword">local</span> handler = <span class="keyword">function</span> ()
                        assert_equal(<span class="number">2</span>, call_counter)
                        call_counter = call_counter + <span class="number">1</span>
                    <span class="keyword">end</span>

    signal:add_pre_emit(pre_emit1)
    signal:add_pre_emit(pre_emit2)
    signal:connect(handler)
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter)
<span class="keyword">end</span>


<span class="keyword">function</span> test_stopping_a_signal_will_not_stop_the_post_emit_functions()
    <span class="keyword">local</span> post_emit = <span class="keyword">function</span> ()
                          assert_equal(<span class="number">1</span>, call_counter)
                          call_counter = call_counter + <span class="number">1</span>
                      <span class="keyword">end</span>

    <span class="keyword">local</span> handler1 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">0</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                         signal:stop()
                     <span class="keyword">end</span>

    <span class="keyword">local</span> handler2 = <span class="keyword">function</span> ()
                         assert_equal(<span class="number">1</span>, call_counter)
                         call_counter = call_counter + <span class="number">1</span>
                     <span class="keyword">end</span>

    signal:add_post_emit(post_emit)
    signal:connect(handler1)
    signal:connect(handler2)
    signal:emit()
    assert_equal(<span class="number">2</span>, call_counter)
<span class="keyword">end</span>


lunit.main()

</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.2</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
